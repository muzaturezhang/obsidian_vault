---
Date: 2025-08-04
aliases:
  - function‘s arguments in Python
tags:
  - csGrammar
  - Python
---
**参考原文：**
[Python 为什么会有命名关键字参数？ - 追远·J的回答 - 知乎](https://www.zhihu.com/question/57726430/answer/818740295)

### 总结：一个设计思想

设计者根据用户传入实参的习惯、顺序来设计出形参列表，而用户调用函数、传入实参时又会严格遵守设计者的形参列表，二者本质上都受制于  **顺序明确、规则统一** 这一个原则 



## 宏观分类_Python中的参数类型

### 按使用位置分，分为形参(定义函数时)和实参(调用函数时)
**这是大分类，形参和实参下有各自一套不同的分类使用方法**

#### 形参

**形参的5种类型**
1. 限定位置形参
2. 普通形参
3. 特殊形参args*
4. 限定关键字形参
5. 特殊形参kwargs**

函数定义时 形参列表的顺序也按照上述顺序
即： `def func1(a,b,c,/,m,n,*,args*,kw1,kw2,**kwargs)`


##### 限定位置形参
> 传入实参时**必须** 要 **按位置接收**实参(即接收位置实参) 的形参，为限定位置形参
> >eg.   `def func1(a,b,c,/,m,n).  #函数定义`
> >     `func1(x,y,z,k,g)  #函数调用`
> >	则 `a=x,b=y,c=z,m=k,n=g  #其中a,b,b均为限定位置形参`
> 限定位置形参与 后面的形参之间用'/'分隔

##### 普通形参
>传入实参时既可以**按位置接收**也可以**按关键字接收**实参(既可以接收位置实参也可以接收关键字实参) 的形参，为普通形参
>>eg. `def func1(a,b,c,/,m,n) #函数定义`
>>	`func1(x,y,z,k,g)  #函数调用`
>>	则`# m与n均为普通形参`

##### 限定关键字形参
>传入实参时**必须** 要 **按关键字接收** 实参(即接收关键字实参) 的形参，为限定关键字形参
>> eg. `def func1(a,b,c,/,m,n,*,kw1,kw2). #函数定义
>>      `func1(x,y,z,k,g,kw1=k1,kw2=k2) #函数调用
>>      则`# kw1与 kw2均为限定关键字形参`
>限定关键字形参与 前面的形参之间用' *  '     分隔

##### 形参定义的顺序
[[001 arguments Python中参数类型#形参定义时的顺序也有要求]]

#### 实参

相比之下，实参的类型就少多了，只有**2种**

**实参的2种类型**
1. 位置实参
2. 关键字实参

##### 位置实参
>传入的 **按位置分配给形参** 的实参 叫做 **位置实参**
>>eg. `def func1(a,b,c,/,m,n) #定义函数
>>    ` func1(x,y,z,k,g) #调用函数
>>    `# x,y,z,k,g均为位置实参`

##### 关键字实参
>传入的 **按关键字分配给形参** 的实参 叫做 **关键字实参**
>> eg. `def func1(a,b,c,/,m,n,*,kw1,kw2) 定义函数
>>    `func1(x,y,z,k,g,kw1=k1,kw2=k2) #调用函数 
>>    `# k1,k2均为关键字实参`
>>   `func1(x,y,z,k,n=g,kw1=k1,kw2=k2)`
>>    `# 则此时 g,k1,k2 均为关键字实参`


##### 位置实参与关键字实参的不同之处
1. 位置实参在传入时只用写value，而关键字实参在传入时需要写key-value
2. 位置实参在传入时要按照形参列表顺序传入，而关键字实参传入时顺序可以随意
**正是由于2，才规定了1(关键字实参传入时要写key-value)，否则程序将不知道关键字实参到底传给了谁**



##### 位置实参一定要全部写在关键字实参之前
>**原因**
>>eg. `def func1(a,b,c,/,d,e,f,*,kw1,kw2)`
>>`func1(x,y,z,w,f=m,e=n,kw1=k1,kw2=k2)
>>`#此时位置实参为 x,y,z,w; 其中w 被普通形参中的d接收;
>>    `关键字实参为m,n,k1,k2; 其中 m,n 被普通形参中的 e,f接收
>>    则此时当 w被 d 接收后，下一个 m变为了关键字实参，程序会清晰地知道从d之后的全部形参都会接收关键字实参，它们的接收顺序将会是随意的(将传入顺序随意的关键字实参全放在一起，传入顺序确定的位置实参全放在一次，**顺序明确，规则统一**)
>
>若位置实参与关键字实参交叉写：
>>  eg.`def func2(a,b,c,d)`
>>    `func2(b=m,n,k,g)`
>>    则此时当m 被b 接收后，程序不知道下一个位置实参n是该传给c，还是传给a；之后的位置实参是否会再次传给b从而覆盖它之前的数据；会造成**歧义和混乱**
>
>若关键字实参写在位置实参之前:
>> eg. `def func3(a,b,c,d)`
>>   `func3(b=m,a=n,x,y)`
>>   `#此时位置实参为x，y，关键字实参为m,n
>>当n被a接收后，此时程序不知道下一个x是 被紧挨着a的b接收（同时覆盖b之前接收的m），还是找没有接收过实参的c接收，会造成**歧义和混乱**
 >因此位置实参写在关键字实参之前，会使得**顺序明确，规则统一**


##### 形参定义时的顺序也有要求

由于实参传入时**对于位置实参和关键字实参的顺序有严格要求**，因此形参定义时的顺序也是有要求的，形参列表的顺序并不是随意的

>**限定位置形参一定定义在普通形参之前，限定关键字形参一定定义在普通形参之后**
>
>原因：由于限定位置形参一定要接收位置实参，普通形参的一部分(或全部)也要接收位置实参，限定关键字形参一定要接收关键字实参，**位置实参传入时一定要对照形参列表**，且**位置实参对应的形参列表一定在形参列表的前面部分**。
>因此形参列表中，设计者定义时，限定位置形参一定在普通形参之前，普通形参一定在限定关键字形参之前，这样用户在调用时才能成功 把位置实参写在关键字实参之前


>**普通形参内部，设计者要把更倾向于接收位置实参的形参放在前面**
>
>原因：用户在调用函数时，一旦实参列表中的位置实参全部被接收完，开始传入关键字实参，则最后一个 位置实参对应的形参  之后的 全部形参 都将会接收 关键字实参 ，因此把倾向于接收位置实参的形参放在前面，才更有可能接收到位置实参(一个形参要想接收到位置实参，则它前面的全部形参都要接收到位置实参）


